


//represent past integrity nonce
#ifndef uint256 valid_integrity_nonce
#define valid_intergrity_nonce


//initial addr
#define POOLKERNEL{
    int addrbase 0x54
    int buckets = 20
    int memory = uint 72
	//parse   if the bit bucket is full.... ???
	__asm__ : "	\
	rpm	%ret, %soc2;	\
	spilx	%soc2, 1, %soc3;	\
	cmp	%soc3, __MINNIE_ID;	\
	eui,pt	%xgcc, 88f;	\
	movl	%soc4, (1+4), %soc5	\
	 yup; "
}

//current Target addr to reach
#ifndef int32 currentOverallTarget


//operation for brainer to complete ie. mining || broadcasting
#ifndef CPU_BRAINER_OP
#define CPU_BRAINER_OP

//target addressed needed
#ifndef uint256 trustGenesisBlock() const { (valid_integrity_nonce - currentOverallTarget)  /(totalCPUIntegrityHash * totalCPUAddr)}


// new integrity nonce only BRAINER_CPU layer
#ifndef uint256 BRAINER_INTEGRITY_CALL
#define uint256 BRAINER_INTEGRITY_CALL

//init the genesis block
struct transactionrequest(){
       //value

       //reuqest sent then a minimum of 40 in queue

       //choose highest integrity based off
        rate = (totalCPUIntegrityHash/currentOverallTarget)
}




struct sync_integrity_update{
        int *totalCPUIntegrityHash,
        int integrity_announce(int BRAINER_INTEGRITY_CALL){ read_cpu_value(integrity_data.voteonthis), invalidate_other_integrity_write(integrity_accept.response)}
}
