 
module Consumer where 
 import Control.Monad.State.Lazy;
 import Data.Prelude;
 

  consumer :: StateT s a d -> s (a Description d) -> StateT s _ 
   instance StateT consumer where 
	consumer s _ = fmap a d -> (fmap a -> get s m a) -> fmap s d 
	do run _ list = consumer s d  
		 | Description a :: StateT a _  -> ( a -> listArray a Descrition d _ ) -> [d] 
	
	run list => consumer.isArray(a d)


  responseCall :: IO -> IOModule c _ -> Handle _ hposn
:  someModule :: IO -> FilePath k _  -> FilePath k (stdin : text/json)   
  data IO someModule where 
	|responseCall => someModule a 
	|someModule k _ -> consumer k s a d  
	|readFile _ -> consumer k 
	|consumer _ =  fmap k a d ->  Either a mempty d    
	|consumer _ d = toString _ d ->  List _ [] || isArray d : String  

  wrap :: StateT s a d ->  (StateT s Desscription(_ d) -> Monad a d) ->  StateT s _ d 
  verify :: StateT s a d -> evalStateT s _ _  -> Monad s a d 	
   data verify where
	wrap = (Description _ d -> someModule a _) -> StateT m a   
	someModule = readFile _ _ -> descript (,) <$> a <*> d memempty 
	verify == for descript <$> a <*> d : [] -> do 
		    |descript[] -> M.list <$> fmap a d -> someModule s
		    |return wrap _ d -> module s a   

   instance StateT verify where
	someModule _ _ = do Arrayt<>m _
				-> a : [] -> m
				-> d : [] -> a 

	someModule _ _ = do stateMapT for fmap s a d -> dataTree s a (Description d : Array<>d ) -> fmap s b _
  			| someModule a d != someModule b _ 
			| return someModule _ _ == verify _ _ 



 someModule(event user data) 







